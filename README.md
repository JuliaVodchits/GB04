# Zerocoder Python OB04 Принципы SOLID
**SOLID** — это акроним, представляющий пять основных принципов объектно-ориентированного программирования и дизайна, 
направленных на улучшение разработки системы, сделав её более понятной, гибкой и поддерживаемой. 
Эти принципы были введены Робертом Мартином, также известным как Uncle Bob, в начале 2000-х.
- принцип единственной ответственности (Single Responsibility Principle);
- принцип открытости/закрытости (Open closed Principle);
- принцип подстановки Барбары Лисков (Liskov substitution Principle);
- принцип разделения интерфейсов (Interface Segregation Principle);
- принцип инверсии зависимости (Dependency Inversion Principle)

___
### file main.py
## Задание: 
Применение Принципа Открытости/Закрытости (Open/Closed Principle) в Разработке Простой Игры
### Цель: 
Цель этого домашнего задание - закрепить понимание и навыки применения принципа открытости/закрытости (Open/Closed Principle), 
одного из пяти SOLID принципов объектно-ориентированного программирования. 
Принцип гласит, что программные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации.

### Задача: 
Разработать простую игру, где игрок может использовать различные типы оружия для борьбы с монстрами. 
  Программа должна быть спроектирована таким образом, чтобы легко можно было добавлять новые типы оружия, 
  не изменяя существующий код бойцов или механизм боя.

### Исходные данные:
Есть класс Fighter, представляющий бойца.
Есть класс Monster, представляющий монстра.
Игрок управляет бойцом и может выбирать для него одно из вооружений для боя.
Шаг 1: Создайте абстрактный класс для оружия
  Создайте абстрактный класс Weapon, который будет содержать абстрактный метод attack().
Шаг 2: Реализуйте конкретные типы оружия
  Создайте несколько классов, унаследованных от Weapon, например, Sword и Bow. 
  Каждый из этих классов реализует метод attack() своим уникальным способом.
Шаг 3: Модифицируйте класс Fighter
  Добавьте в класс Fighter поле, которое будет хранить объект класса Weapon.
  Добавьте метод changeWeapon(), который позволяет изменить оружие бойца.
Шаг 4: Реализация боя
  Реализуйте простой механизм для демонстрации боя между бойцом и монстром, исходя из выбранного оружия.
  
### Требования к заданию:
Код должен быть написан на Python.
Программа должна демонстрировать применение принципа открытости/закрытости: новые типы оружия можно легко добавлять, 
не изменяя существующие классы бойцов и механизм боя.
Программа должна выводить результат боя в консоль.

### Пример результата:
Боец выбирает меч.
Боец наносит удар мечом.
Монстр побежден!
Боец выбирает лук.
Боец наносит удар из лука.
Монстр побежден!

### Реализация:
Решено было усложнить задачу, добавить параметры:
- ОЖ монстра (убавляются с каждым ударом + теряются от кровотечения)
- скорость и факт кровотечения (каждый ход убавляет какое-то значение от ОЖ)
- сила воина (увеличивает урон оружия)
- урон оружия (влияет на скорость убывания ОЖ у монстра)

Бой ведется до окончания ОЖ у монстра. Результат каждого удара выводится

### Пример вывода реализованной программы:
* Огр Петя имеет 30 ОЖ
* Не выбрано оружие
* Воин Юлия атаковал монстра Огр Петя оружием Меч. У монстра осталось 19 ОЖ
* Воин Юлия атаковал монстра Огр Петя оружием Меч. У монстра осталось 7 ОЖ
* Воин Юлия атаковал монстра Огр Петя оружием Меч и победил!
* Голем Вася имеет 40 ОЖ
* Воин Юлия атаковал монстра Голем Вася оружием Топор. У монстра осталось 24 ОЖ
* Воин Юлия атаковал монстра Голем Вася оружием Топор. У монстра осталось 8 ОЖ
* Воин Юлия атаковал монстра Голем Вася оружием Топор и победил!
* Привидение Зина имеет 18 ОЖ
* Воин Юлия атаковал монстра Привидение Зина оружием Лук. У монстра осталось 13 ОЖ
* Воин Юлия атаковал монстра Привидение Зина оружием Лук. У монстра осталось 6 ОЖ
* Воин Юлия атаковал монстра Привидение Зина оружием Лук и победил!

___
## Дополнительные файлы
### file p1_SRP.py - Принцип единственной ответственности (Single Responsibility Principle)
Принцип единственной ответственности гласит, что каждый класс должен иметь только одну причину для изменения. 
Это означает, что класс должен выполнять только одну задачу или иметь только одну область ответственности. 
Это упрощает тестирование и поддержку кода.
### file p2_OCP.py - Принцип открытости/закрытости (OCP, Open/Closed Principle)
Программные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации. 
Суть в том, что уже существующий код не должен модифиироваться при добавлении новых функций. 
Это достигается за счёт использования абстракций и интерфейсов.
### file p3_LSP.py - Принцип подстановки Барбары Лисков (LSP, Liskov substitution Principle)
Объекты в программе должны быть заменяемыми на экземпляры подтипов без влияния на правильность программы. 
Это значит, что объекты производного класса должны иметь возможность заменить объекты базового класса без изменения работы программы.
### file p4_ISP.py - Принцип разделения интерфейсов (ISP, Interface Segregation Principle)
Клиенты не должны быть вынуждены зависеть от интерфейсов, которые они не используют. 
Суть в создании специализированных интерфейсов вместо одного, делающего всё подряд. 
Это упрощает внедрение зависимостей и повышает гибкость системы.Объекты в программе 
должны быть заменяемыми на экземпляры подтипов без влияния на правильность программы. 
Это значит, что объекты производного класса должны иметь возможность заменить объекты базового класса без изменения работы программы.
### file p5_DIP.py - Принцип инверсии зависимости (DIP, Dependency Inversion Principle)
Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба типа модулей должны зависеть от абстракций.
Абстракции не должны зависеть от деталей; детали должны зависеть от абстракций. Это позволяет разрабатывать систему более гибкой 
и способствует её лёгкому тестированию.
